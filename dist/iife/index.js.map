{"version":3,"sources":["../../node_modules/csv-stream/lib/parser.js","../../node_modules/csv-stream/index.js","../../node_modules/post-entity/lib/post-entity.js","../../node_modules/post-entity/index.js","../../src/index.ts"],"sourcesContent":["/*!\n * csv-stream\n * Copyright(c) 2012 HipSnip Limited\n * Author Rémy Loubradou <remyloubradou@gmail.com>\n * MIT Licensed\n */\n\n/**\n * Modules dependencies\n */\n\nvar EventEmitter = require('events').EventEmitter,\n\tutil = require('util');\n\nmodule.exports = Parser;\n\nfunction Parser(options){\n\tEventEmitter.call(this);\n\tthis.delimiter = options ? options.delimiter || ',' : ',';\n\tthis.endLine = options ? options.endLine || '\\n' : '\\n';\n\tthis.enclosedChar = options ? options.enclosedChar || '' : '';\n\tthis.escapeChar = options ? options.escapeChar || '' : '';\n\tthis.columnOffset = options ? options.columnOffset || 0 : 0;\n\n\tthis._defaultColumns =  options ? !!options.columns : false;\n\tthis.columns = options ? options.columns || [] : [];\n\tthis._currentColumn = 0;\n\tthis._index = 0;\n\tthis._line = {};\n\tthis._text = '';\n\tthis._enclosing = null;\n}\n\n\n// Inherits from EventEmitter\nutil.inherits(Parser,EventEmitter);\n\nParser.prototype.end = function(s){\n\tif(s) this.parse(s);\n\tif(this._text || Object.getOwnPropertyNames(this._line).length){\n\t\tif(this._text[this._text.length -1] === '\\r') this._text = this._text.slice(0,this._text.length - 1);\n\t\tthis.emit('column',this.columns[this._currentColumn],this._text);\n\t\tthis._line[this.columns[this._currentColumn]] = this._text;\n\t\tthis.emit('data',this._line);\n\t}\n\tthis.emit('end');\n}\n\nParser.prototype.parse = function(s){\n\tfor(var i = 0; i < s.length; i++){\n\t\tvar c = s[i];\n\t\tif(this.escapeChar === c && this._enclosing && s[i+1] === this.enclosedChar){\n\t\t\ti++;\n\t\t\tthis._text = this._text + s[i];\n\t\t}else{\n\t\t\tif(this.enclosedChar === c){\n\t\t\t\tthis._enclosing = !this._enclosing;\n\t\t\t}else if(this.delimiter === c){\n\t\t\t\tif(this._enclosing){\n\t\t\t\t\tthis._text = this._text + c;\n\t\t\t\t}else{\n\t\t\t\t\tif(this._index < this.columnOffset){\n\t\t\t\t\t\t//skip line\n\t\t\t\t\t}else if(this._index === this.columnOffset && !this._defaultColumns){\n\t\t\t\t\t\tthis.columns[this._currentColumn] = this._text;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tthis.emit('column',this.columns[this._currentColumn],this._text);\n\t\t\t\t\t\tthis._line[this.columns[this._currentColumn]] = this._text;\n\t\t\t\t\t}\n\t\t\t\t\tthis._text = '';\n\t\t\t\t\tthis._currentColumn++;\n\t\t\t\t}\n\t\t\t}else if(this.endLine === c){ //LF\n\t\t\t\tif(this._enclosing){\n\t\t\t\t\tthis._text = this._text + c;\n\t\t\t\t}else{\n\t\t\t\t\tif(this._text[this._text.length -1] === '\\r') this._text = this._text.slice(0,this._text.length - 1);\n\t\t\t\t\tif(this._index < this.columnOffset){\n\t\t\t\t\t\t//skip line\n\t\t\t\t\t}else if(this._index === this.columnOffset && !this._defaultColumns){\n\t\t\t\t\t\tthis.columns[this._currentColumn] = this._text;\n\t\t\t\t\t\tthis.emit('header',this.columns);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tthis.emit('column',this.columns[this._currentColumn],this._text);\n\t\t\t\t\t\tthis._line[this.columns[this._currentColumn]] = this._text;\n\t\t\t\t\t\tthis.emit('data',this._line);\n\t\t\t\t\t}\n\t\t\t\t\tthis._index++;\n\t\t\t\t\tthis._currentColumn = 0;\n\t\t\t\t\tthis._line = {};\n\t\t\t\t\tthis._text = '';\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tthis._text = this._text + c;\n\t\t\t}\n\t\t}\n\n\t}\n}\n","/*!\n * csv-stream\n * Copyright(c) 2012 HipSnip Limited\n * Author Rémy Loubradou <remyloubradou@gmail.com>\n * MIT Licensed\n */\n\n/**\n * Modules dependencies\n */\n\nvar Stream = require('stream'),\n\tutil = require('util'),\n\tParser = require('./lib/parser');\n\nexports.createStream = function(options){\n\treturn new CSVStream(options || {});\n}\n\nfunction CSVStream(options){\n\tvar self = this;\n\tStream.call(this);\n\n\t// States\n\tthis.writable = true;\n\tthis.readable = true;\n\tthis._paused = false;\n\tthis._ended = false;\n\tthis._destroyed = false;\n\tthis._endCallWhenPause = false;\n\n\t// Buffer\n\tthis._buffer = new Buffer(0);\n\tthis._encoding = undefined; // Encoding needs to be undefined for Buffer.toString method\n\n\t// CSV parser\n\tthis._parser = new Parser(options);\n\tthis._parser.on('data',function(data){\n\t\tif(self._ended) throw new Error('Must not emit data event after emittion of end event.')\n\t\tself.emit('data',data);\n\t});\n\tthis._parser.on('column',function(key,value){\n\t\tself.emit('column',key,value);\n\t});\n\tthis._parser.on('header',function(header){\n\t\tself.emit('header',header);\n\t});\n\tthis._parser.on('end',function(){\n\t\tself._ended = true;\n\t\tself.readable = false;\n\t\tself.emit('end');\n\t});\n}\n\nutil.inherits(CSVStream,Stream);\n\nCSVStream.prototype.write = function(buffer,encoding){\n\tthis._encoding = encoding || this._encoding;\n\tif(this._ended) throw new Error('Cannot write after end has been called.');\n\tif(buffer) this._buffer = Buffer.concat([this._buffer, buffer], this._buffer.length + buffer.length);\n\tif(this._paused) return false;\n\tthis._parser.parse(this._buffer.toString(this._encoding));\n\tthis._buffer = new Buffer(0);\n\treturn !this._paused;\n}\n\nCSVStream.prototype.end = function(buffer,encoding){\n\tif(this._buffer || buffer){\n\t\tif(this.write(buffer,encoding)){\n\t\t\tthis.writable = false;\n\t\t\tthis._parser.end();\n\t\t\tif(!this._destroyed) this.destroy();\n\t\t}else{\n\t\t\tthis._endCallWhenPause = true;\n\t\t}\n\t}\n}\n\nCSVStream.prototype.destroy = function(){\n\tthis._buffer = null;\n\tthis._destroyed = true;\n\tthis.emit('close');\n}\n\nCSVStream.prototype.pause = function(){\n\tthis._paused = true;\n}\n\nCSVStream.prototype.resume = function(){\n\tthis._paused = false;\n\tif(this._buffer && this._buffer.length > 0 && !this._endCallWhenPause) this.write();\n\tif(this._endCallWhenPause) this.end();\n\tthis.emit('drain');\n}\n","var pe = {\n\n  /**\n   * Types are name & regular expression objected used to extract entities.\n   * All types must be a global regex for the entity extraction to work\n   */\n  types: [\n    { name: 'hashtag',\n      regexp: /#\\w+/g },\n    { name: 'cashtag',\n      regexp: /\\$[A-Z]+/g },\n    { name: 'mention',\n      regexp: /@\\w+/g },\n    { name: 'link',\n      regexp: /(\\b(https?|ftp|file):\\/\\/[-A-Z0-9+&@#\\/%?=~_|!:,.;]*[-A-Z0-9+&@#\\/%=~_|])/ig }\n  ],\n\n  /**\n   * Extracts entities as specified in the types object from a string.\n   * Optionally pass in your own array of types in the same form as pe.types\n   * to have it extract anything.\n   *\n   * Return an array of entities, ordered by index.\n   */\n  entities: function (str, types) {\n    if (!str && str !== '') throw new Error(\"Entities requires a non-empty string.\");\n    types = types || pe.types;\n    if (!types) throw new Error(\"No types found.\");\n    var entities = [];\n    types.forEach(function (type) {\n      var match;\n      while ((match = type.regexp.exec(str)) !== null) {\n        entities.push({\n          type: type.name,\n          index: match.index,\n          raw: match[0]\n        });\n      }\n    });\n    return entities.sort(function (a, b) {\n      return a.index > b.index;\n    });\n  },\n\n  /**\n   * Turns a string into a parsed array of enties: those defined in types and\n   * text blocks.\n   *\n   * Returns an array of entities.\n   */\n  process: function (str, types) {\n    var entities = pe.entities(str, types),\n        segments = [],\n        remaining = str,\n        removed = 0;\n    entities.forEach(function (entity) {\n      // Figure out where the entity begins and ends\n      var entityStart = entity.index - removed,\n          entityEnd = entityStart + entity.raw.length,\n          pre = remaining.slice(0, entityStart);\n      // There's some text before this – add it\n      if (pre) {\n        segments.push({\n          type: 'text',\n          raw: pre,\n          index: removed\n        });\n      }\n      // Push the current entity\n      segments.push(entity);\n      // Update what was remove and what's left over for the next entity\n      remaining = remaining.slice(entityEnd);\n      removed += entityEnd;\n    });\n    segments.push({\n      type: 'text',\n      raw: remaining,\n      index: removed\n    });\n    return segments;\n  }\n};\n\nmodule.exports = pe;","module.exports = require('./lib/post-entity.js');","import * as csv from 'csv-stream';\r\nimport { open } from 'node:fs/promises';\r\nimport * as pe from 'post-entity';\r\n\r\nconst file = process.argv[2] || 'tests/test.csv' || '';\r\n\r\nif (file === '') {\r\n  throw new RangeError();\r\n}\r\n\r\nconst tokens = {};\r\n// Initialize the parser\r\nconst options = {\r\n  delimiter: '\\t',\r\n  endLine: '\\n',\r\n  columnOffset: 0,\r\n  escapeChar: '\"',\r\n  enclosedChar: '\"',\r\n};\r\n\r\nconst csvStream = csv.createStream(options);\r\n\r\nlet prompt = `Using a list of words where the number after the comma is how frequently the word is used, please summarize the personality, interests, fears, and hopes of the person using these words from the list (and account for frequency): \r\n\r\n`;\r\n\r\n/**\r\n *\r\n */\r\nasync function main() {\r\n  const fd = await open(file, 'r');\r\n  const stream = fd.createReadStream();\r\n  stream\r\n    .pipe(csvStream)\r\n\r\n    .on('data', function (data) {\r\n      // outputs an object containing a set of key/value pair representing a line found in the csv file.\r\n      if (data.retweet !== 'False') {\r\n        return;\r\n      }\r\n\r\n      if (data.language !== 'en') {\r\n        return;\r\n      }\r\n\r\n      const text = pe\r\n        .process(data.tweet)\r\n        .filter((tweet) => tweet.type === 'text')\r\n        .map((tweet) => tweet.raw.trim());\r\n\r\n      for (const words of text) {\r\n        const split = words.split(' ');\r\n        for (const element of split) {\r\n          const token = element.trim();\r\n          if (token !== '') {\r\n            if (tokens[token] === undefined) {\r\n              tokens[token] = 0;\r\n            }\r\n            tokens[token] += 1;\r\n          }\r\n        }\r\n      }\r\n    })\r\n\r\n    .on('close', function () {\r\n      const keys = Object.keys(tokens);\r\n\r\n      for (const key of keys) {\r\n        if (tokens[key] === 1) {\r\n          continue;\r\n        }\r\n        prompt += `${key}:${tokens[key]} `;\r\n      }\r\n\r\n      console.log(prompt);\r\n    });\r\n}\r\n\r\nmain();\r\n"],"mappings":"4wBAAA,IAAAA,EAAAC,EAAA,CAAAC,EAAAC,IAAA,CAWA,IAAIC,EAAe,EAAQ,QAAQ,EAAE,aACpCC,EAAO,EAAQ,MAAM,EAEtBF,EAAO,QAAUG,EAEjB,SAASA,EAAOC,EAAQ,CACvBH,EAAa,KAAK,IAAI,EACtB,KAAK,UAAYG,GAAUA,EAAQ,WAAa,IAChD,KAAK,QAAUA,GAAUA,EAAQ,SAAW;AAAA,EAC5C,KAAK,aAAeA,GAAUA,EAAQ,cAAgB,GACtD,KAAK,WAAaA,GAAUA,EAAQ,YAAc,GAClD,KAAK,aAAeA,GAAUA,EAAQ,cAAgB,EAEtD,KAAK,gBAAmBA,EAAU,CAAC,CAACA,EAAQ,QAAU,GACtD,KAAK,QAAUA,EAAUA,EAAQ,SAAW,CAAC,EAAI,CAAC,EAClD,KAAK,eAAiB,EACtB,KAAK,OAAS,EACd,KAAK,MAAQ,CAAC,EACd,KAAK,MAAQ,GACb,KAAK,WAAa,IACnB,CAIAF,EAAK,SAASC,EAAOF,CAAY,EAEjCE,EAAO,UAAU,IAAM,SAASE,EAAE,CAC9BA,GAAG,KAAK,MAAMA,CAAC,GACf,KAAK,OAAS,OAAO,oBAAoB,KAAK,KAAK,EAAE,UACpD,KAAK,MAAM,KAAK,MAAM,OAAQ,CAAC,IAAM,OAAM,KAAK,MAAQ,KAAK,MAAM,MAAM,EAAE,KAAK,MAAM,OAAS,CAAC,GACnG,KAAK,KAAK,SAAS,KAAK,QAAQ,KAAK,cAAc,EAAE,KAAK,KAAK,EAC/D,KAAK,MAAM,KAAK,QAAQ,KAAK,cAAc,CAAC,EAAI,KAAK,MACrD,KAAK,KAAK,OAAO,KAAK,KAAK,GAE5B,KAAK,KAAK,KAAK,CAChB,EAEAF,EAAO,UAAU,MAAQ,SAASE,EAAE,CACnC,QAAQC,EAAI,EAAGA,EAAID,EAAE,OAAQC,IAAI,CAChC,IAAIC,EAAIF,EAAEC,CAAC,EACR,KAAK,aAAeC,GAAK,KAAK,YAAcF,EAAEC,EAAE,CAAC,IAAM,KAAK,cAC9DA,IACA,KAAK,MAAQ,KAAK,MAAQD,EAAEC,CAAC,GAE1B,KAAK,eAAiBC,EACxB,KAAK,WAAa,CAAC,KAAK,WAChB,KAAK,YAAcA,EACxB,KAAK,WACP,KAAK,MAAQ,KAAK,MAAQA,GAEvB,KAAK,OAAS,KAAK,eAEb,KAAK,SAAW,KAAK,cAAgB,CAAC,KAAK,gBACnD,KAAK,QAAQ,KAAK,cAAc,EAAI,KAAK,OAEzC,KAAK,KAAK,SAAS,KAAK,QAAQ,KAAK,cAAc,EAAE,KAAK,KAAK,EAC/D,KAAK,MAAM,KAAK,QAAQ,KAAK,cAAc,CAAC,EAAI,KAAK,QAEtD,KAAK,MAAQ,GACb,KAAK,kBAEE,KAAK,UAAYA,EACtB,KAAK,WACP,KAAK,MAAQ,KAAK,MAAQA,GAEvB,KAAK,MAAM,KAAK,MAAM,OAAQ,CAAC,IAAM,OAAM,KAAK,MAAQ,KAAK,MAAM,MAAM,EAAE,KAAK,MAAM,OAAS,CAAC,GAChG,KAAK,OAAS,KAAK,eAEb,KAAK,SAAW,KAAK,cAAgB,CAAC,KAAK,iBACnD,KAAK,QAAQ,KAAK,cAAc,EAAI,KAAK,MACzC,KAAK,KAAK,SAAS,KAAK,OAAO,IAE/B,KAAK,KAAK,SAAS,KAAK,QAAQ,KAAK,cAAc,EAAE,KAAK,KAAK,EAC/D,KAAK,MAAM,KAAK,QAAQ,KAAK,cAAc,CAAC,EAAI,KAAK,MACrD,KAAK,KAAK,OAAO,KAAK,KAAK,IAE5B,KAAK,SACL,KAAK,eAAiB,EACtB,KAAK,MAAQ,CAAC,EACd,KAAK,MAAQ,IAGd,KAAK,MAAQ,KAAK,MAAQA,EAK9B,IClGA,IAAAC,EAAAC,EAAAC,GAAA,CAWA,IAAIC,EAAS,EAAQ,QAAQ,EAC5BC,EAAO,EAAQ,MAAM,EACrBC,EAAS,IAEVH,EAAQ,aAAe,SAASI,EAAQ,CACvC,OAAO,IAAIC,EAAUD,GAAW,CAAC,CAAC,CACnC,EAEA,SAASC,EAAUD,EAAQ,CAC1B,IAAIE,EAAO,KACXL,EAAO,KAAK,IAAI,EAGhB,KAAK,SAAW,GAChB,KAAK,SAAW,GAChB,KAAK,QAAU,GACf,KAAK,OAAS,GACd,KAAK,WAAa,GAClB,KAAK,kBAAoB,GAGzB,KAAK,QAAU,IAAI,OAAO,CAAC,EAC3B,KAAK,UAAY,OAGjB,KAAK,QAAU,IAAIE,EAAOC,CAAO,EACjC,KAAK,QAAQ,GAAG,OAAO,SAASG,EAAK,CACpC,GAAGD,EAAK,OAAQ,MAAM,IAAI,MAAM,uDAAuD,EACvFA,EAAK,KAAK,OAAOC,CAAI,CACtB,CAAC,EACD,KAAK,QAAQ,GAAG,SAAS,SAASC,EAAIC,EAAM,CAC3CH,EAAK,KAAK,SAASE,EAAIC,CAAK,CAC7B,CAAC,EACD,KAAK,QAAQ,GAAG,SAAS,SAASC,EAAO,CACxCJ,EAAK,KAAK,SAASI,CAAM,CAC1B,CAAC,EACD,KAAK,QAAQ,GAAG,MAAM,UAAU,CAC/BJ,EAAK,OAAS,GACdA,EAAK,SAAW,GAChBA,EAAK,KAAK,KAAK,CAChB,CAAC,CACF,CAEAJ,EAAK,SAASG,EAAUJ,CAAM,EAE9BI,EAAU,UAAU,MAAQ,SAASM,EAAOC,EAAS,CAEpD,GADA,KAAK,UAAYA,GAAY,KAAK,UAC/B,KAAK,OAAQ,MAAM,IAAI,MAAM,yCAAyC,EAEzE,OADGD,IAAQ,KAAK,QAAU,OAAO,OAAO,CAAC,KAAK,QAASA,CAAM,EAAG,KAAK,QAAQ,OAASA,EAAO,MAAM,GAChG,KAAK,QAAgB,IACxB,KAAK,QAAQ,MAAM,KAAK,QAAQ,SAAS,KAAK,SAAS,CAAC,EACxD,KAAK,QAAU,IAAI,OAAO,CAAC,EACpB,CAAC,KAAK,QACd,EAEAN,EAAU,UAAU,IAAM,SAASM,EAAOC,EAAS,EAC/C,KAAK,SAAWD,KACf,KAAK,MAAMA,EAAOC,CAAQ,GAC5B,KAAK,SAAW,GAChB,KAAK,QAAQ,IAAI,EACb,KAAK,YAAY,KAAK,QAAQ,GAElC,KAAK,kBAAoB,GAG5B,EAEAP,EAAU,UAAU,QAAU,UAAU,CACvC,KAAK,QAAU,KACf,KAAK,WAAa,GAClB,KAAK,KAAK,OAAO,CAClB,EAEAA,EAAU,UAAU,MAAQ,UAAU,CACrC,KAAK,QAAU,EAChB,EAEAA,EAAU,UAAU,OAAS,UAAU,CACtC,KAAK,QAAU,GACZ,KAAK,SAAW,KAAK,QAAQ,OAAS,GAAK,CAAC,KAAK,mBAAmB,KAAK,MAAM,EAC/E,KAAK,mBAAmB,KAAK,IAAI,EACpC,KAAK,KAAK,OAAO,CAClB,IC7FA,IAAAQ,EAAAC,EAAA,CAAAC,EAAAC,IAAA,KAAIC,EAAK,CAMP,MAAO,CACL,CAAE,KAAM,UACN,OAAQ,OAAQ,EAClB,CAAE,KAAM,UACN,OAAQ,WAAY,EACtB,CAAE,KAAM,UACN,OAAQ,OAAQ,EAClB,CAAE,KAAM,OACN,OAAQ,6EAA8E,CAC1F,EASA,SAAU,SAAUC,EAAKC,EAAO,CAC9B,GAAI,CAACD,GAAOA,IAAQ,GAAI,MAAM,IAAI,MAAM,uCAAuC,EAE/E,GADAC,EAAQA,GAASF,EAAG,MAChB,CAACE,EAAO,MAAM,IAAI,MAAM,iBAAiB,EAC7C,IAAIC,EAAW,CAAC,EAChB,OAAAD,EAAM,QAAQ,SAAUE,EAAM,CAE5B,QADIC,GACIA,EAAQD,EAAK,OAAO,KAAKH,CAAG,KAAO,MACzCE,EAAS,KAAK,CACZ,KAAMC,EAAK,KACX,MAAOC,EAAM,MACb,IAAKA,EAAM,CAAC,CACd,CAAC,CAEL,CAAC,EACMF,EAAS,KAAK,SAAUG,EAAGC,EAAG,CACnC,OAAOD,EAAE,MAAQC,EAAE,KACrB,CAAC,CACH,EAQA,QAAS,SAAUN,EAAKC,EAAO,CAC7B,IAAIC,EAAWH,EAAG,SAASC,EAAKC,CAAK,EACjCM,EAAW,CAAC,EACZC,EAAYR,EACZS,EAAU,EACd,OAAAP,EAAS,QAAQ,SAAUQ,EAAQ,CAEjC,IAAIC,EAAcD,EAAO,MAAQD,EAC7BG,EAAYD,EAAcD,EAAO,IAAI,OACrCG,EAAML,EAAU,MAAM,EAAGG,CAAW,EAEpCE,GACFN,EAAS,KAAK,CACZ,KAAM,OACN,IAAKM,EACL,MAAOJ,CACT,CAAC,EAGHF,EAAS,KAAKG,CAAM,EAEpBF,EAAYA,EAAU,MAAMI,CAAS,EACrCH,GAAWG,CACb,CAAC,EACDL,EAAS,KAAK,CACZ,KAAM,OACN,IAAKC,EACL,MAAOC,CACT,CAAC,EACMF,CACT,CACF,EAEAT,EAAO,QAAUC,ICnFjB,IAAAe,EAAAC,EAAA,CAAAC,EAAAC,IAAA,CAAAA,EAAO,QAAU,MCAjB,IAAAC,EAAqB,OACrBC,EAAqB,iBACrBC,EAAoB,OAEdC,EAAO,QAAQ,KAAK,CAAC,GAAK,iBAEhC,GAAIA,IAAS,GACX,MAAM,IAAI,WAGZ,IAAMC,EAAS,CAAC,EAEVC,EAAU,CACd,UAAW,IACX,QAAS;AAAA,EACT,aAAc,EACd,WAAY,IACZ,aAAc,GAChB,EAEMC,EAAgB,eAAaD,CAAO,EAEtCE,EAAS;AAAA;AAAA,EAOb,eAAeC,GAAO,EACT,QAAM,QAAKL,EAAM,GAAG,GACb,iBAAiB,EAEhC,KAAKG,CAAS,EAEd,GAAG,OAAQ,SAAUG,EAAM,CAM1B,GAJIA,EAAK,UAAY,SAIjBA,EAAK,WAAa,KACpB,OAGF,IAAMC,EACH,UAAQD,EAAK,KAAK,EAClB,OAAQE,GAAUA,EAAM,OAAS,MAAM,EACvC,IAAKA,GAAUA,EAAM,IAAI,KAAK,CAAC,EAElC,QAAWC,KAASF,EAAM,CACxB,IAAMG,EAAQD,EAAM,MAAM,GAAG,EAC7B,QAAWE,KAAWD,EAAO,CAC3B,IAAME,EAAQD,EAAQ,KAAK,EACvBC,IAAU,KACRX,EAAOW,CAAK,IAAM,SACpBX,EAAOW,CAAK,EAAI,GAElBX,EAAOW,CAAK,GAAK,IAIzB,CAAC,EAEA,GAAG,QAAS,UAAY,CACvB,IAAMC,EAAO,OAAO,KAAKZ,CAAM,EAE/B,QAAWa,KAAOD,EACZZ,EAAOa,CAAG,IAAM,IAGpBV,GAAU,GAAGU,KAAOb,EAAOa,CAAG,MAGhC,QAAQ,IAAIV,CAAM,CACpB,CAAC,CACL,CAEAC,EAAK","names":["require_parser","__commonJSMin","exports","module","EventEmitter","util","Parser","options","s","i","c","require_csv_stream","__commonJSMin","exports","Stream","util","Parser","options","CSVStream","self","data","key","value","header","buffer","encoding","require_post_entity","__commonJSMin","exports","module","pe","str","types","entities","type","match","a","b","segments","remaining","removed","entity","entityStart","entityEnd","pre","require_post_entity","__commonJSMin","exports","module","csv","import_promises","pe","file","tokens","options","csvStream","prompt","main","data","text","tweet","words","split","element","token","keys","key"]}